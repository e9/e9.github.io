<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2018/10 on e9.github.io</title>
    <link>https://e9.github.io/tags/2018/10/</link>
    <description>Recent content in 2018/10 on e9.github.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Wed, 31 Oct 2018 19:36:34 +0900</lastBuildDate>
    
	<atom:link href="https://e9.github.io/tags/2018/10/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>RedisのHGETALLの速さ</title>
      <link>https://e9.github.io/posts/1540982193/</link>
      <pubDate>Wed, 31 Oct 2018 19:36:34 +0900</pubDate>
      
      <guid>https://e9.github.io/posts/1540982193/</guid>
      <description>普段は Redis の読み書きなんてフレームワークにまかせていて、オブジェクトならだいたいシリアライズして保存されているわけだけど、今回たまたま Redis を直で使うことがあった。ハッシュ、連想配列、辞書、まあとにかくそんなものを保存したい。
単純にやるなら JSON 文字列に変換して保存すればいいわけだけど、シリアライズには多少なりとも時間がかかる。そもそも Redis はハッシュが扱えるので、そのままハッシュとして保存すればいいんじゃないか？と思った。
で、ドキュメントを見たんだけど、Redis のハッシュは O(N)らしいのだ。
 http://redis.shibu.jp/commandreference/hashes.html  うーん、それじゃあ JSON とどっちが速いのかは分からない。
ちゃんと調べた人もいて、それによると JSON の方が速いらしい。まあ、微々たるもんだからどっちでもいいんだけど。
 https://symfoware.blog.fc2.com/blog-entry-1446.html  </description>
    </item>
    
    <item>
      <title>配列と連想配列を同じループで回したい</title>
      <link>https://e9.github.io/posts/1539859215/</link>
      <pubDate>Thu, 18 Oct 2018 19:40:15 +0900</pubDate>
      
      <guid>https://e9.github.io/posts/1539859215/</guid>
      <description>Python。dict か list のいずれかが入っている変数に対して、ループで回してある処理をすることになった。
型が違うのだから違うコードで回すべきだという論もあるだろうが、せっかく LL で書いているのだから、全く同じコードで処理したいところ。
結局自分はこうした。
items = dict_or_list.items() if isinstance(dict_or_list, dict) else enumerate(dict_or_list) for key, value in items: print(key, value)  条件分岐があまり美しくない気がしたけど、より良い方法が思いつかなかった。
Ruby だともうちょっと美しく書ける。
hash_or_array.each_with_index{ |(k, v), i| value, key = [v, k, i].compact p [key, value] }  まあ、これが美しいコードなのかは異論あるだろうけど、条件分岐が無いのが売りである。</description>
    </item>
    
  </channel>
</rss>